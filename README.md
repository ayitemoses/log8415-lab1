# LOG8415E - Lab 1: Load balancer from scratch

## Prerequisites

### Install pyenv in home
curl https://pyenv.run | bash

### Add to shell init
export PATH="$HOME/.pyenv/bin:$PATH"
eval "$(pyenv init -)"

### Install python 3.11 locally
pyenv install 3.11.9
pyenv local 3.11.9


## File structure

```
.
├── app/
│   └── main.py             # FastAPI application for cluster instances
├── artifacts/              # Generated by scripts, stores state
│   ├── instances.json
│   └── lb.json
├── lb/
│   └── lb.py               # Custom latency-based load balancer logic
├── scripts/
│   ├── bootstrap_env.sh    # (Step 1) Prepares AWS resources (Key Pair, SG)
│   ├── provision_instances.py # Provisions the 8 application EC2 instances
│   ├── deploy_fastapi.py   # Deploys the FastAPI app to the instances
│   ├── provision_lb.py     # Provisions the load balancer EC2 instance
│   ├── deploy_lb.py        # Deploys the load balancer app
│   ├── benchmark.py        # (Step 4) Runs performance tests
│   └── teardown.py         # Helper script for stop.sh to remove resources
├── .env                    # Generated by bootstrap, stores resource IDs
├── run.sh                  # (Step 2) Main script to build and deploy everything
├── stop.sh                 # (Step 5) Main script to destroy everything
└── README.md               # This file
```

## How to run

### Prerequisites

1.  **AWS Account:** An AWS account with programmatic access (Access Key ID and Secret Access Key).
2.  **AWS CLI:** The AWS Command Line Interface must be installed.
3.  **Configuration:** Your AWS credentials must be configured. Run `aws configure` and provide your credentials and a default region (e.g., `us-east-1`).
4.  **Required Tools:** The control machine must have `python3`, `pip`, `curl`, and `jq` installed.

### Step-by-Step Instructions

#### Step 1: Bootstrap Environment (Run Once)

This script creates the necessary AWS resources that persist between deployments, such as the EC2 Key Pair and the main Security Group. It also creates a `.env` file to store the IDs of these resources.

```bash
./scripts/bootstrap_env.sh
```

#### Step 2: Deploy the Entire Infrastructure

This is the master script that provisions all instances, deploys the applications, configures the load balancer, and brings the entire system online.

```bash
./run.sh
```

Upon successful completion, the script will output the public IP address of the load balancer.

#### Step 3: Test the System

You can manually verify that the system is working by sending requests to the cluster endpoints.

```bash
# Replace <LB_IP> with the IP address from the run.sh output
LB_IP="<LB_IP>"

# Test Cluster 1 (t2.large instances)
curl -s http://${LB_IP}/cluster1 ; echo

# Test Cluster 2 (t2.micro instances)
curl -s http://${LB_IP}/cluster2 ; echo

# Check the real-time status of the load balancer
curl -s http://${LB_IP}/status | jq
```

#### Step 4: Run the Performance Benchmark

This script sends 1000 concurrent requests to each cluster and reports performance metrics like Requests Per Second (RPS) and average latency.

```bash
# Activate the virtual environment
source .venv/bin/activate

# Install benchmark dependencies
pip install aiohttp

# Run the benchmark
python scripts/benchmark.py http://${LB_IP}
```
**Note:** The results of this benchmark are the primary data for the project analysis.

#### Step 5: Destroy All Resources

**This is a critical step to avoid incurring AWS costs.** The `stop.sh` script will automatically find and terminate all EC2 instances created by this project and delete the associated security groups and local artifacts.

```bash
./stop.sh --confirm
```
